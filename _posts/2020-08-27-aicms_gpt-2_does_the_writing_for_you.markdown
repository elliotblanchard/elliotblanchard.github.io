---
layout: post
title:      "AICMS: GPT-2 does the writing for you."
date:       2020-08-28 02:20:24 +0000
permalink:  aicms_gpt-2_does_the_writing_for_you
---

AI is big news. Not a week goes by without a new development in the field. GPT-2, the second-generation language prediction created by OpenAI, is one of the AI projects getting a lot of that press. GPT-2 is seen as a major breakthrough in producing high-quality written content - so high quality that OpenAI initially [feared the project was too dangerous to release](https://www.theguardian.com/technology/2019/feb/14/elon-musk-backed-ai-writes-convincing-news-fiction). Luckily, OpenAI had a change of heart and released a modified version of the GPT-2 algorithm for the rest of us to get familiar with.

<iframe src="https://giphy.com/embed/eiucmDa1QGFPT02diS" width="480" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

I had been wanting to work with GPT-2 for quite some time, and our Rails project was the perfect opportunity. What could be better than a content management system that writes the content for you?
# Failing To Plan Is Planning To Fail
In addition to working with AI content generation, I also wanted to spend more time upfront on a game plan before I started coding. And I'm glad I did. The few hours I dedicated to building a solid schema and a full set of wireframes made a big difference when I sat down to work. Understanding and thinking through the overall structure of the project made it much easier to focus on the details during implementation.

![](https://i.imgur.com/bOWmBO7.png)
# Too Much Is Never Enough
I was excited to work with GPT-2, but integrating AI into the project meant more work up front. GPT-2 is built with a default AI generator model, but it also allows for the creation of *custom generators*.  I wanted to give users the option of choosing between several generated writing styles, so I built two additional custom generators to compliment the standard model. Building a really good generator requires a huge library of written material for the AI to learn from. Collecting and preparing these texts - the "corpus" - took several days. 

![](https://i.imgur.com/rJ0fqCG.png)

Once the generators were built and running, I needed a way for my Rails project to communicate with them. This was my first opportunity to work with APIs in Ruby. As with everything else, there was a Gem available that made it easy. [HTTParty](https://rubygems.org/gems/httparty) made it simple to implement the interface, and the JSON structuring was a snap to parse and integrate. 
# Diving In
<iframe src="https://giphy.com/embed/Vzk5PFo9iH5AEustmv" width="480" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

Once the GPT-2 was ready, I turned to building the Rails app. I used a straightforward approach with three primary models:

1. Users
2. Documents
3. Generators

Each *user* can create many *documents*. Each document contains a writing prompt (as well as parameters for the  generators) as well as the response generated by the GPT-2 AI. So, for example, if I provided a prompt like this: 

“In my younger and more vulnerable years my father gave me some advice that I’ve been turning over in my mind ever since.”

The GPT-2 generator would then continue the thought:

“If you don’t fall in love with your first love it will be too late. A good first kiss is the key to all of your future lovers, make sure to develop a good first kiss down pat because you will thank me in the end for the many times that I have spared your sorry ass from that huge headache you call a relationship.”

Fresh, right? 

This means that each of the three *generators* has many *documents*. In turn, a *document* belongs to a single *user* and a single *generator* - and finally, a *user* has many *generators* through *documents* (and vice versa) 

This structure provided a solid foundation to built the app on. The build process was a great chance to integrate nested resources, Active Record validations, error reporting, and scope methods. As with my previous projects, I found the portfolio project to be the smoothest part of the Rails module - all of the previous sections, labs, and exercises were a great preparation for AICMS.
# Final Touches
Although not a project requirement, I wanted to make AICMS a pleasing user experience. I haver really enjoyed working with the [Bulma CSS Framework](https://bulma.io/) on my [previous Sinatra project](https://elliotblanchard.github.io/want_to_put_your_cli_project_online_here_s_what_i_learned), so I integrated it into AICMS to give it a nice final touch. 

I've had a great time learning Rails over the past few weeks, and I am happy that I was able to integrate AI content generation into my final project. I look forward to continuing to work with both as I move forward in the Flatiron curriculum. 

To learn more about AICMS, check out the Git Repo at [https://github.com/elliotblanchard/rails-final-aicms](https://github.com/elliotblanchard/rails-final-aicms) - or get in touch!






